#![allow(dead_code)]
use cypher_user::*;

pub struct CypherMarketMaker {
    pub market_info: CypherMarketInfo,
    pub market_user: CypherMarketUser
}

/// TODO
/// add serum math for trading fns in order to place orders in lot sizes
impl CypherMarketMaker {
    pub async fn init(
        group_address: Pubkey,
        user_kp: Keypair,
        rpc: &RpcClient,
        market_idx: usize,
    ) -> Result<CypherMarketMaker> {
        Ok(CypherMarketUser.init(group_address, user_kp, rpc, market_idx))
    }





    pub async fn deposit_margin_account_collateral(&self, amount: u64) -> Vec<Instruction> {
        let ixs: Vec<Instruction> = CypherMarketUser::get_deposit_collateral_ix(&self.CypherMarketUser, amount);
        ixs
    }

    pub async fn withdraw_margin_account_collateral(&self, amount: u64) -> Vec<Instruction> {
        let ixs: Vec<Instruction> = CypherMarketUser::withdraw_collateral(&self.CypherMarketUser, amount);
        ixs
    }

    pub async fn deposit_mint_collateral(&self, amount: u64) -> Vec<Instruction> {
        let ixs: Vec<Instruction> = CypherMarketUser::deposit_market_collateral(&self.CypherMarketMaker, amount);
        ixs
    }

    pub async fn withdraw_mint_collateral(&self, amount: u64) -> Vec<Instruction> {
        let ixs: Vec<Instruction> = CypherMarketUser::withdraw_market_collateral(&self.CypherMarketMaker, amount);
        ixs
    }

    pub async fn bid_ask_ix(&self, ix_data: NewOrderInstructionV3) -> Instruction {
        let ix: Instruction = CypherMarketUser::new_order_v3(&self.CypherMarketUser, ix_data);
        ix
    }

    pub async fn cancel_bid_ask_ix(
        &self, 
        group: &CypherGroupInfo, 
        ix_data: CancelOrderInstructionV2
    ) -> Instruction {
        let ix: Instruction = CypherMarketUser::cancel_order_v2(&self.CypherMarketUser, group, ix_data);
        ix
    }
    
    pub async fn settle_funds_ix(&self, group: &mut CypherGroupInfo) -> Instruction {
        let ix: Instruction = CypherMarketUser::get_settle_funds_ix(&self.CypherMarketUser, group);
        ix
    }

    /// TODO
    /// not sure if this is needed, could be for executing markts
    pub async fn settle_positions_ixs() -> Instruction {

    }

    /// TODO
    /// work through the multiple ixs here
    pub async fn cancel_mint_and_sell_then_withdraw_mint_collateral_ixs(
        &self, 
        group: &CypherGroupInfo, 
        ix_data: CancelOrderInstructionV2, 
        amount: u64
    ) -> Vec<Instruction> {
        let ixs: Vec<Instruction> = get_request_builder()
    }

    pub async fn buy_and_burn_minted_positions_ixs(&self, max_repay_amount: u64) -> Vec<Instruction> {
        let ixs: Vec<Instruction> = CypherMarketUser::get_buy_and_burn_ixs(&self.CypherMarketUser, max_repay_amount);
        ixs
    }

    pub fn get_market_positions(&self, group: &CypherGroupInfo, token_idx: usize) -> Number {
        let net_position: Number = CypherMarketUser::get_deposit_position(&self.CypherMarketUser, group, token_idx) - CypherMarketUser::get_borrow_position(&self.CypherMarketUser, group, token_idx);
    }

    /// TODO
    /// write get minted positions ix becasue its not in cypher_users
    pub async fn get_minted_positions_ix() -> {

    }

    pub fn get_mint_c_ratio(&self, group: &CypherGroupInfo, market_idx: usize) ->  Number {
        let mint_c_ratio: Number = CypherMarketUser::get_mint_c_ratio(&self.CypherMarketUser, group, market_idx);
    }

    /// TODO
    /// get orders in cypher_user cancels in same fn, check to see if this is necessay
    /// or if needs to be broken out into get_orders and get_orders_and_cancel
    pub async fn get_open_orders(&self, dex_oo_acc: Account) -> {

    }

    pub async fn get_mkt_spread() -> {

    }

    pub async fn get_updated_account_state_ix() -> {

    }
 }